#include <texture_types.h>
#include <surface_types.h>

__constant__ float pre_sigmar[2048];

texture<unsigned short, cudaTextureType2D, cudaReadModeElementType> inputTexture;
texture<unsigned char, cudaTextureType2D, cudaReadModeElementType> foregroundColorTexture;
surface<void, cudaSurfaceType2D> outputSurface;
surface<void, cudaSurfaceType2D> finalOutputSurface;
surface<void, cudaSurfaceType2D> maskSurface;
surface<void, cudaSurfaceType2D> alphaSurface;
surface<void, cudaSurfaceType2DLayered> gaussiansSurface;
surface<void, cudaSurfaceType2DLayered> sortingSurface;
//surface<void, cudaSurfaceType2DLayered> gaussiansAuxSurface;
//surface<void, cudaSurfaceType2DLayered> sortingAuxSurface;

//#include "cudamog.cu"
#include <texture_types.h>
#include <texture_fetch_functions.h>
#include <surface_types.h>
#include <surface_functions.h>
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include "cudamog.h"
#include "generalcuda.h"
#include "mogconfig.h"
#include "detectedparameters.h"
#include "cudaimages.h"


extern "C" void setPre_sigmaR2(float *h_Kernel, size_t mem_size){
    CUDA_SAFE_CALL (cudaMemcpyToSymbol(pre_sigmar, h_Kernel, mem_size));
}

template <typename CUDA_VECTOR>
class VectorWrapper : public CUDA_VECTOR {
public:
    __device__ void read (surface<void, cudaSurfaceType2DLayered> surf, int x, int y, int layer) {
        surf2DLayeredread<CUDA_VECTOR> (this, surf, sizeof(CUDA_VECTOR) * x, y, layer);
    }
    __device__ void write (surface<void, cudaSurfaceType2DLayered> surf, int x, int y, int layer) const {
        surf2DLayeredwrite<CUDA_VECTOR> (*this, surf, sizeof(CUDA_VECTOR) * x, y, layer);
    }
    __device__ VectorWrapper (surface<void, cudaSurfaceType2DLayered> surf, int x, int y, int layer) {
        this->read(surf, x, y, layer);
    }
    __device__ VectorWrapper () {}
};

template <typename STORAGE_CLASS>
class GaussianParametersTemplate : public VectorWrapper<STORAGE_CLASS> {
public:
    __device__ void setMean (float mean) { this->x = mean; }
    __device__ void setStdDev (float stdDev) {this->y = stdDev; }
    __device__ float getMean () const { return this->x; }
    __device__ float getStdDev () const { return this->y; }
	__device__ GaussianParametersTemplate (float mean, float stdDev) { this->setMean(mean); this->setStdDev(stdDev);}
    __device__ GaussianParametersTemplate (surface<void, cudaSurfaceType2DLayered> surf, int x, int y, int layer) {
        this->read(surf, x, y, layer);
    }
    __device__ GaussianParametersTemplate () {}
};

template <typename STORAGE_CLASS>
class SortingParametersTemplate : public VectorWrapper<STORAGE_CLASS> {
public:
    __device__ float getWeight () const { return this->x; }
    __device__ float getSortingKey () const { return this->y; }
	//__device__ float getStdDevMin () const { return this->z; }
    __device__ void setWeight (float weight) { this->x = weight; }
    __device__ void setSortingKey (float sortingKey) { this->y = sortingKey; }
	//__device__ void setStdDevMin (float stdDevMin) {this->z = stdDevMin; }
    __device__ void updatePositiveMatch (float alpha, float stdDevSum, float sigmaInit) {
        this->setWeight((1.0f - alpha) * this->getWeight () + alpha);
        this->setSortingKey(this->getWeight () / (stdDevSum/sigmaInit));
    }
    __device__ void updateNegativeMatch (float alpha) {
        this->setWeight((1.0f - alpha) * this->getWeight ());
        this->setSortingKey((1.0f - alpha) * this->getSortingKey ());
    }
    //__device__ SortingParametersTemplate (float weight, float sortingKey, float stdDevMin) { this->setWeight(weight); this->setSortingKey(sortingKey); this->setStdDevMin(stdDevMin);}
	__device__ SortingParametersTemplate (float weight, float sortingKey) { this->setWeight(weight); this->setSortingKey(sortingKey);}
    __device__ SortingParametersTemplate () {}
    __device__ SortingParametersTemplate (surface<void, cudaSurfaceType2DLayered> surf, int x, int y, int layer) {
        this->read(surf, x, y, layer);
    }
};


//template <int COMPONENTS, typename SOURCE_CHANNEL_TYPE>
//__device__ void initializePixel (float pixel[COMPONENTS]);
template <typename SOURCE_CHANNEL_TYPE>
__device__ void initializePixel (unsigned short int pixel[], unsigned short int *inputDepth, int width);

template <int COMPONENTS, typename CUDA_VECTOR_T>
__device__ bool matchesMode(const MoGConfig &config,
                            const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters[COMPONENTS],
                            const unsigned short int pixel[COMPONENTS]) {
    float sum = 0.0f;
    for (int i = 0; i < COMPONENTS; ++i) {
        const float diff = pixel[i] - gaussianParameters[i].getMean();
        const float ratio = diff / gaussianParameters[i].getStdDev();
        sum += (ratio * ratio);
    }
    return (sum < (config.lambda * config.lambda));
}

__device__ void calcSigma(float mean, float a, float b, float c, float deltaSigma, float *sigmaMin, float *sigma0){
	//*sigmaMin = c+b*(mean)+a*(mean)*(mean);
	int idx = mean/3;
	*sigmaMin = pre_sigmar[idx];
	*sigma0 = *sigmaMin * deltaSigma;
}

template <int COMPONENTS, typename CUDA_VECTOR_T>
MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::MixtureOfGaussians (MoGConfig          const *config,
                                                                   DetectedParameters const *parameters,
																   cudaArray				**colorArray,
																   cudaArray				**CmapArray)
    : config (*config),
      parameters (*parameters),
      initialised (false),
      processedFrames (0),
      blockSize (config->blockWidth, config->blockHeight),
      gridSize (((parameters->width + blockSize.x - 1) / blockSize.x),
                ((parameters->height + blockSize.y - 1) / blockSize.y))
{
    this->inputArray = allocateArrayForImage<CUDA_VECTOR_T>(this->parameters.width, this->parameters.height);

    inputTexture.addressMode[0] = cudaAddressModeBorder;
    inputTexture.addressMode[1] = cudaAddressModeBorder;
    inputTexture.filterMode = cudaFilterModePoint;
    inputTexture.normalized = false;
    CUDA_SAFE_CALL (cudaBindTextureToArray(inputTexture, this->inputArray));

	//this->foregroundColorArray = allocateArrayForImage<unsigned char>(this->parameters.width, this->parameters.height);
	this->foregroundColorArray = *colorArray;

    foregroundColorTexture.addressMode[0] = cudaAddressModeBorder;
    foregroundColorTexture.addressMode[1] = cudaAddressModeBorder;
    foregroundColorTexture.filterMode = cudaFilterModePoint;
    foregroundColorTexture.normalized = false;
    CUDA_SAFE_CALL (cudaBindTextureToArray(foregroundColorTexture, this->foregroundColorArray));

    this->outputArray = allocateArrayForImage<unsigned char>(this->parameters.width, this->parameters.height);
    CUDA_SAFE_CALL (cudaBindSurfaceToArray (outputSurface, this->outputArray));

	this->finalOutputArray = allocateArrayForImage<unsigned char>(this->parameters.width, this->parameters.height);
    CUDA_SAFE_CALL (cudaBindSurfaceToArray (finalOutputSurface, this->finalOutputArray));

	this->maskArray = allocateArrayForImage<unsigned char>(this->parameters.width, this->parameters.height);
    CUDA_SAFE_CALL (cudaBindSurfaceToArray (maskSurface, this->maskArray));

	*CmapArray = this->maskArray;

	this->alphaArray = allocateArrayForImage<unsigned char>(this->parameters.width, this->parameters.height);
    CUDA_SAFE_CALL (cudaBindSurfaceToArray (alphaSurface, this->alphaArray));

    const cudaExtent gaussiansArrayDims = make_cudaExtent(this->parameters.width, this->parameters.height, COMPONENTS * this->config.k); // Docs say width should be bytes, but it's actually elements
    const cudaChannelFormatDesc gaussiansArrayFormat = cudaCreateChannelDesc<GAUSSIAN_STORAGE_T>();
    CUDA_SAFE_CALL (cudaMalloc3DArray (&this->gaussiansArray, &gaussiansArrayFormat, gaussiansArrayDims, cudaArrayLayered | cudaArraySurfaceLoadStore));
    CUDA_SAFE_CALL (cudaBindSurfaceToArray (gaussiansSurface, this->gaussiansArray));

    const cudaExtent sortingArrayDims = make_cudaExtent(this->parameters.width, this->parameters.height, this->config.k); // Docs say width should be bytes, but it's actually elements
    const cudaChannelFormatDesc sortingArrayFormat = cudaCreateChannelDesc<SORTING_STORAGE_T> ();
    CUDA_SAFE_CALL (cudaMalloc3DArray (&this->sortingArray, &sortingArrayFormat, sortingArrayDims, cudaArrayLayered | cudaArraySurfaceLoadStore));
    CUDA_SAFE_CALL (cudaBindSurfaceToArray (sortingSurface, this->sortingArray));

	//const cudaExtent gaussiansAuxArrayDims = make_cudaExtent(this->parameters.width, this->parameters.height, COMPONENTS * this->config.k); // Docs say width should be bytes, but it's actually elements
 //   const cudaChannelFormatDesc gaussiansAuxArrayFormat = cudaCreateChannelDesc<GAUSSIAN_STORAGE_T>();
 //   CUDA_SAFE_CALL (cudaMalloc3DArray (&this->gaussiansAuxArray, &gaussiansAuxArrayFormat, gaussiansAuxArrayDims, cudaArrayLayered | cudaArraySurfaceLoadStore));
 //   CUDA_SAFE_CALL (cudaBindSurfaceToArray (gaussiansAuxSurface, this->gaussiansAuxArray));

	//const cudaExtent sortingAuxArrayDims = make_cudaExtent(this->parameters.width, this->parameters.height, this->config.k); // Docs say width should be bytes, but it's actually elements
 //   const cudaChannelFormatDesc sortingAuxArrayFormat = cudaCreateChannelDesc<SORTING_STORAGE_T> ();
 //   CUDA_SAFE_CALL (cudaMalloc3DArray (&this->sortingAuxArray, &sortingAuxArrayFormat, sortingAuxArrayDims, cudaArrayLayered | cudaArraySurfaceLoadStore));
 //   CUDA_SAFE_CALL (cudaBindSurfaceToArray (sortingAuxSurface, this->sortingAuxArray));
}

template<int COMPONENTS, typename CUDA_VECTOR_T>
MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::~MixtureOfGaussians ()
{
    CUDA_SAFE_CALL (cudaFreeArray(this->inputArray));
	//CUDA_SAFE_CALL (cudaFreeArray(this->foregroundColorArray));
    CUDA_SAFE_CALL (cudaFreeArray(this->outputArray));
	CUDA_SAFE_CALL (cudaFreeArray(this->maskArray));
	CUDA_SAFE_CALL (cudaFreeArray(this->alphaArray));
    CUDA_SAFE_CALL (cudaFreeArray(this->gaussiansArray));
    CUDA_SAFE_CALL (cudaFreeArray(this->sortingArray));
	//CUDA_SAFE_CALL (cudaFreeArray(this->gaussiansAuxArray));
	//CUDA_SAFE_CALL (cudaFreeArray(this->sortingAuxArray));
}

template <int COMPONENTS, typename CUDA_VECTOR_T>
__global__ void mogInitialiseKernel (MoGConfig           config,
                                     DetectedParameters  parameters,
									 unsigned short int *inputDepth,
									 float a, float b, float c, float deltaSigma) {
    const int x = blockIdx.x * blockDim.x + threadIdx.x;
    const int y = blockIdx.y * blockDim.y + threadIdx.y;

    if ((parameters.width <= x) || (parameters.height <= y)) { return; }

	//float a = 0.00000235;
	//float b = 0.00055;
	//float c = 2.3;

    // TODO: Hacer algo para cuando hay sólo un canal (depth)
    
	unsigned short int pixel[COMPONENTS];
	
	initializePixel<CUDA_VECTOR_T>(pixel, inputDepth, parameters.width);

	if (pixel[0] == 0){
		// Not initialized
		const unsigned char initialized = 0;
		surf2Dwrite<unsigned char> (initialized, maskSurface, sizeof (unsigned char) * x, y);
		// This first frame is unconditionally classified as background.
		//const unsigned char background = 0;
		//surf2Dwrite<unsigned char> (background, outputSurface, sizeof (unsigned char) * x, y);
		//surf2Dwrite<unsigned char> (background, finalOutputSurface, sizeof (unsigned char) * x, y);
		return;
	}

	unsigned char processedPixels = 1;
	surf2Dwrite<unsigned char> (processedPixels, alphaSurface, sizeof (unsigned char) * x, y);

	//const unsigned char initialized = 255;
	// Initialized but not stable
	const unsigned char initialized = 128;
	surf2Dwrite<unsigned char> (initialized, maskSurface, sizeof (unsigned char) * x, y);

    // We initialize all the modes with the same parameters using this first
    // image. Since they are tried in order, they will slowly evolve to
    // reflect actual modes of the sequence.
	//float sigma0 = config.sigma_0;
	//float sigmaMin = config.sigma_min;

	//const float sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
	//const float sigma0 = deltaSigma * sigmaMin;

	float sigmaMin;
	float sigma0;

	calcSigma(pixel[0], a, b, c, deltaSigma, &sigmaMin, &sigma0);

    const float initialWeight  = 1.0f / static_cast<float>(config.k);
    //float initialSortkey = initialWeight / (static_cast<float>(COMPONENTS) * sigma0); //config.sigma_0
	const float initialSortkey = initialWeight;
	/*if (COMPONENTS == 1){
		sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
		sigma0 = 2.5 * sigmaMin;
		initialSortkey *= sigma0;
	}*/
    for (int mode = 0; mode < config.k; ++mode) {
        //for (int component = 0; component < COMPONENTS; ++component) {
            const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters (pixel[0], sigma0); //config.sigma_0
            gaussianParameters.write(gaussiansSurface, x, y, COMPONENTS * mode);
        //}
        const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (initialWeight, initialSortkey);
        sortingParameters.write(sortingSurface, x, y, mode);
    }

    // This first frame is unconditionally classified as background.
    //const unsigned char background = 0;
    //surf2Dwrite<unsigned char> (background, outputSurface, sizeof (unsigned char) * x, y);
	//surf2Dwrite<unsigned char> (background, finalOutputSurface, sizeof (unsigned char) * x, y);
}




template <int COMPONENTS, typename CUDA_VECTOR_T>
__global__ void mogProcessKernel (float alpha,
                                  MoGConfig           config,
                                  DetectedParameters  parameters,
								  unsigned short int  *inputDepth,
								  unsigned short int  *modelo,
								  float a, float b, float c, float deltaSigma, float weightMin, float sigmaMax, int cMin)
{
    const int x = blockIdx.x * blockDim.x + threadIdx.x;
    const int y = blockIdx.y * blockDim.y + threadIdx.y;

    if ((parameters.width <= x) || (parameters.height <= y)) { return; }

	//float a = 0.00000235;
	//float b = 0.00055;
	//float c = 2.3;

    unsigned short int pixel[COMPONENTS];
	initializePixel<CUDA_VECTOR_T> (pixel, inputDepth, parameters.width);

	if (pixel[0] == 0){ 
		unsigned char background = 0;
		surf2Dwrite<unsigned char> (background, outputSurface, sizeof (unsigned char) * x, y);	
		//const unsigned char readData = tex2D(foregroundColorTexture, x, y);
		//const unsigned char readData = 255;
		//surf2Dwrite<unsigned char> (readData, finalOutputSurface, sizeof (unsigned char) * x, y);
		return; 
	}

	unsigned char initialized;

	surf2Dread<unsigned char> (&initialized, maskSurface, sizeof (unsigned char) *x, y);

	float sigmaMin; //= config.sigma_min;
	float sigma0;

	if (initialized == 0){

		unsigned char processedPixels = 1;
		surf2Dwrite<unsigned char> (processedPixels, alphaSurface, sizeof (unsigned char) * x, y);

		// Initialized but not stable
		initialized = 128;
		surf2Dwrite<unsigned char> (initialized, maskSurface, sizeof (unsigned char) * x, y);

		// We initialize all the modes with the same parameters using this first
		// image. Since they are tried in order, they will slowly evolve to
		// reflect actual modes of the sequence.

		//sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
		//sigma0 = deltaSigma * sigmaMin;

		calcSigma(pixel[0], a, b, c, deltaSigma, &sigmaMin, &sigma0);

		const float initialWeight  = 1.0f / static_cast<float>(config.k);
		const float initialSortkey = initialWeight;
		//float initialSortkey = initialWeight / (static_cast<float>(COMPONENTS) * config.sigma_0);
		//float sigma0 = config.sigma_0;
		/*if (COMPONENTS == 1){
			sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
			sigma0 = sigmaMin * 2.5;
			initialSortkey *= sigma0;
		}*/
		for (int mode = 0; mode < config.k; ++mode) {
			//for (int component = 0; component < COMPONENTS; ++component) {
				const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters (pixel[0], sigma0);
				gaussianParameters.write(gaussiansSurface, x, y, COMPONENTS * mode);
			//}
			const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (initialWeight, initialSortkey);
			sortingParameters.write(sortingSurface, x, y, mode);
		}

		// This first pixel with valid data is unconditionally classified as background.
		//const unsigned char background = 0;
		//surf2Dwrite<unsigned char> (background, outputSurface, sizeof (unsigned char) * x, y);
		//surf2Dwrite<unsigned char> (background, finalOutputSurface, sizeof (unsigned char) * x, y);

		return;
	}

	unsigned char processedPixels;
	surf2Dread<unsigned char> (&processedPixels, alphaSurface, sizeof (unsigned char) *x, y);
	if (processedPixels < static_cast<unsigned char>(1.0f/config.alpha_min))
		processedPixels++;
	alpha = 1.0f / static_cast<float>(processedPixels);
	surf2Dwrite<unsigned char> (processedPixels, alphaSurface, sizeof (unsigned char) * x, y);
	

    int matchingMode = -1; // Not valid match
    for (int mode = 0; mode < config.k; ++mode) {
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (sortingSurface, x, y, mode);
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters[COMPONENTS];
        //for (int component = 0; component < COMPONENTS; ++component) {
            gaussianParameters[0].read(gaussiansSurface, x, y, COMPONENTS * mode);
        //}
        // Only the first matching mode is considered
        if ((0 > matchingMode) && (matchesMode<COMPONENTS, CUDA_VECTOR_T>(config, gaussianParameters, pixel))) {
            matchingMode = mode;
            //const float SQRT_2PI = 2.506628275f;
            float rho = alpha;


/////////////	Aproximación del rho
            // TODO : Preguntar qué pichas hacer con la normalización, aunque tiene pinta de que normFactor = 1,
            // dado que rho debe estar entre 0 y 1 y alpha también lo está.
            //float normFactor = SQRT_2PI;
            //for (int component = 0; component < COMPONENTS; ++component) {
                const float arg = (pixel[0] - gaussianParameters[0].getMean())
                                  / gaussianParameters[0].getStdDev();
                // TODO: Cambiar esta exponencial por la tabla
                rho *= __expf(-0.5f * arg * arg);
                // TODO : Preguntar qué pichas hacer con la normalización
                //normFactor *= gaussianParameters[component].getStdDev();
            //}
            //rho /= normFactor;


			//rho /= sortingParameters.getWeight ();


            float stdDevSum = 0.0f;
			//float sigmaMin = config.sigma_min;
			//float sigma0 = config.sigma_0;
			//float sigma0 = 1; //Para que no me afecte en el color
			//if (COMPONENTS ==1){
			//sigmaMin = c+b*(gaussianParameters[0].getMean())+a*(gaussianParameters[0].getMean())*(gaussianParameters[0].getMean());
			//const float sigma0 = sigmaMin * 2.5;
			//float sigma0;
			//}
            //for (int component = 0; component < COMPONENTS; ++component) {
                gaussianParameters[0].setMean((1.0f - rho) * gaussianParameters[0].getMean()
                                                      + rho * pixel[0]);
                // TODO : Cerciorarse de que primero se actualiza la media y luego se actualiza la stdDev
//                gaussianParameters[component].setStdDev((1.0f - rho) * gaussianParameters[component].getStdDev()
//                                                        + rho * fabsf (pixel[component] - gaussianParameters[component].getMean()));
				//sigmaMin = c+b*(gaussianParameters[0].getMean())+a*(gaussianParameters[0].getMean())*(gaussianParameters[0].getMean());
				//sigma0 = sigmaMin * deltaSigma;
				calcSigma(gaussianParameters[0].getMean(), a, b, c, deltaSigma, &sigmaMin, &sigma0);

                gaussianParameters[0].setStdDev(__fsqrt_rn((1.0f - rho) * gaussianParameters[0].getStdDev() * gaussianParameters[0].getStdDev()
                                                        + rho * (pixel[0] - gaussianParameters[0].getMean()) * (pixel[0] - gaussianParameters[0].getMean())));
                gaussianParameters[0].setStdDev((sigmaMin > gaussianParameters[0].getStdDev())
                                                        ? sigmaMin : gaussianParameters[0].getStdDev());
                stdDevSum += gaussianParameters[0].getStdDev ();
                gaussianParameters[0].write(gaussiansSurface, x, y, COMPONENTS * mode);
            //}
            sortingParameters.updatePositiveMatch(alpha, stdDevSum, sigma0);
        } else {
            sortingParameters.updateNegativeMatch(alpha);
        }
        sortingParameters.write(sortingSurface, x, y, mode);
    }

  //////////// ((-1 == matchingMode) && (300 == x) && (240 == y)) ? printf ("No hay cerillas\n") : 0;
    // If the match is in the first mode we do not need to reorder the modes
    if (0 < matchingMode) {
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters matchingGaussian[COMPONENTS];
        //for (int c = 0; c < COMPONENTS; ++c) {
            matchingGaussian[0].read(gaussiansSurface, x, y, COMPONENTS * matchingMode);
        //}
        const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters matchingSorting (sortingSurface, x, y, matchingMode);

        for (int mode = (matchingMode - 1); mode >= -1; --mode) {
            {
                const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters otherSorting (sortingSurface, x, y, mode);
                if (otherSorting.getSortingKey() >= matchingSorting.getSortingKey() || mode == -1) {
                    matchingSorting.write(sortingSurface, x, y, mode + 1);
                    //for (int c = 0; c < COMPONENTS; ++c) {
                        matchingGaussian[0].write(gaussiansSurface, x, y, COMPONENTS * (mode + 1));
                    //}
                    matchingMode = mode + 1;
                    break;
                }
                otherSorting.write(sortingSurface, x, y, mode + 1);
            }
            //for (int c = 0; c < COMPONENTS; ++c) {
                const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters otherGaussian (gaussiansSurface, x, y, COMPONENTS * mode);
                otherGaussian.write(gaussiansSurface, x, y, COMPONENTS * (mode + 1));
            //}
        }
    }

    // If there was no match, we must insert a new mode in place of the
    // last mode
    if (-1 == matchingMode) {
        matchingMode = config.k - 1;

		//sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
		//const float sigma0 = sigmaMin * deltaSigma;
		calcSigma(pixel[0], a, b, c, deltaSigma, &sigmaMin, &sigma0);

        const float initialWeight = config.w_0;
		const float initialSortkey = initialWeight;
        //float initialSortkey = initialWeight / (COMPONENTS * config.sigma_0);
		//float sigma0 = config.sigma_0;
		//float sigmaMin = config.sigma_min;
		//if (COMPONENTS == 1){
			//sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
			//sigma0 = sigmaMin * 2.5;
			//initialSortkey *= sigma0;
		//}
        //for (int component = 0; component < COMPONENTS; ++component) {
            const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters (pixel[0], sigma0);
            //((x == 200) && (y == 200)) ? printf ("  sigma_0: %f\n", getStdDev(gaussianParameters)) : 0;
            gaussianParameters.write(gaussiansSurface, x, y, COMPONENTS * matchingMode);
        //}
        const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (initialWeight, initialSortkey);
        sortingParameters.write(sortingSurface, x, y, matchingMode);
    }

	// If initialized but not stable, we must check if it becomes stable (only Mode 0)
	if (initialized < 128+cMin){
		int mode = 0;
		typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (sortingSurface, x, y, mode);
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters[COMPONENTS];
        //for (int component = 0; component < COMPONENTS; ++component) {
            gaussianParameters[0].read(gaussiansSurface, x, y, COMPONENTS * mode);
        //}

		const float stdDevSum = gaussianParameters[0].getStdDev ();
		//float stdDevSum = 0.0f;
		//float stdDevSumMin = 0.0f;
        //for (int component = 0; component < COMPONENTS; ++component){
			//stdDevSum += gaussianParameters[component].getStdDev ();
			////stdDevSumMin += sortingParameters.getStdDevMin();
		//}
		const float weight = sortingParameters.getWeight();

		if ((weight > weightMin) && (stdDevSum <= sigmaMax*sigmaMin)){
			//initialized = 255;
			initialized++;
			surf2Dwrite<unsigned char> (initialized, maskSurface, sizeof (unsigned char) * x, y);
		}

	}

    // Now we must renormalize the weights of the modes before classifying the
    // pixel as fore- or background.
    float weightNormalization = 0.0f;
    float accumulatedWeightBeforeMatch = 0.0f;
    bool pixelIsBackground;
    for (int mode = 0; mode < config.k; ++mode) {
        const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (sortingSurface, x, y, mode);
        weightNormalization += sortingParameters.getWeight();
    }
    for (int mode = 0; mode < config.k; ++mode) {
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (sortingSurface, x, y, mode);
        const float newWeight = sortingParameters.getWeight() / weightNormalization;
//        accumulatedWeightBeforeMatch += newWeight;
//        sortingParameters.setWeight(newWeight);
//        sortingParameters.setSortingKey(sortingParameters.getSortingKey() / weightNormalization);
//        sortingParameters.write (sortingSurface, x, y, mode);
        if (mode == matchingMode) {
          pixelIsBackground = (accumulatedWeightBeforeMatch < config.thresh) ? true : false;
        }
		//if (matchingMode == 2)
			//pixelIsBackground = true;
        accumulatedWeightBeforeMatch += newWeight;
        sortingParameters.setWeight(newWeight);
        sortingParameters.setSortingKey(sortingParameters.getSortingKey() / weightNormalization);
        sortingParameters.write (sortingSurface, x, y, mode);
    }

	//if (initialized == 255){
	if (initialized > 127){
		int mode;
		if (pixelIsBackground)
			mode = matchingMode;
			//mode = 0;
		else
			mode = 0;
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters[COMPONENTS];
        for (int component = 0; component < COMPONENTS; ++component) {
            gaussianParameters[component].read(gaussiansSurface, x, y, COMPONENTS * mode + component);
        }
		modelo[y*parameters.width + x] = gaussianParameters[0].getMean ();
	}
	else
		modelo[y*parameters.width + x] = 0;

  /////////////  ((x == 300) && (y == 240)) ? printf ("%d\n", matchingMode) : 0;
    /*if (pixelIsBackground || initialized < 255) {
        const unsigned char finalPixel = 0;
        surf2Dwrite<unsigned char> (finalPixel, outputSurface, sizeof(unsigned char) * x, y);
		surf2Dwrite<unsigned char> (finalPixel, finalOutputSurface, sizeof (unsigned char) * x, y);
    } else {
        const unsigned char finalPixel = 255;
        surf2Dwrite<unsigned char> (finalPixel, outputSurface, sizeof(unsigned char) * x, y);
		surf2Dwrite<unsigned char> (finalPixel, finalOutputSurface, sizeof (unsigned char) * x, y);
    }*/
}


template<int COMPONENTS, typename CUDA_VECTOR_T>
void MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::processImage (Mat const *input, Mat *output, Mat *finalOutput, unsigned short int *inputDepth, unsigned short int *modeloDepth, float a, float b, float c, float deltaSigma, float weightMin, float sigmaMax, int cMin)
//void MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::processImage (fipImage const *input, fipImage* output)
{
    /*++this->processedFrames;
    float alpha = 1.0f / static_cast<float>(this->processedFrames);
    if (alpha < this->config.alpha_min) {
        alpha = this->config.alpha_min;
    }*/
    float alpha = 0.0f;
    //copyImageToArray(*input, this->inputArray);
	//this->foregroundColorArray = inputColorArray;
    if (!this->initialised) {
        this->initialised = true;
        mogInitialiseKernel<COMPONENTS, CUDA_VECTOR_T>
                           <<<this->gridSize, this->blockSize>>>(this->config,
                                                                 this->parameters,
																 inputDepth,
																 a, b, c, deltaSigma);
        CUDA_SAFE_CALL (cudaGetLastError());
    } else {
        mogProcessKernel<COMPONENTS, CUDA_VECTOR_T>
                        <<<this->gridSize, this->blockSize>>>(alpha,
                                                              this->config,
                                                              this->parameters,
															  inputDepth,
															  modeloDepth,
															  a, b, c, deltaSigma, weightMin, sigmaMax, cMin);
    }
    //copyImageFromArray(*output, this->outputArray);
	//copyImageFromArray(*finalOutput, this->finalOutputArray);
}

template <int COMPONENTS, typename CUDA_VECTOR_T>
__global__ void mogProcessOnlyDetectionKernel (float alpha,
                                  MoGConfig           config,
                                  DetectedParameters  parameters,
								  unsigned short int  *inputDepth,
								  Npp8u*              filledOutput,
								  float a, float b, float c, float deltaSigma)
{
    const int x = blockIdx.x * blockDim.x + threadIdx.x;
    const int y = blockIdx.y * blockDim.y + threadIdx.y;

    if ((parameters.width <= x) || (parameters.height <= y)) { return; }

	//float a = 0.00000235;
	//float b = 0.00055;
	//float c = 2.3;

    unsigned short int pixel[COMPONENTS];
	initializePixel<CUDA_VECTOR_T> (pixel, inputDepth, parameters.width);

	if (pixel[0] == 0){ 
		//unsigned char background = 0;
		//surf2Dwrite<unsigned char> (background, outputSurface, sizeof (unsigned char) * x, y);	
		const unsigned char readData = tex2D(foregroundColorTexture, x, y);
		//const unsigned char readData = 0;
		//surf2Dwrite<unsigned char> (readData, finalOutputSurface, sizeof (unsigned char) * x, y);
		filledOutput[y*parameters.width + x] = readData;
		return; 
	}

	unsigned char initialized;

	surf2Dread<unsigned char> (&initialized, maskSurface, sizeof (unsigned char) *x, y);

	float sigmaMin; //= config.sigma_min;
	float sigma0;

	if (initialized == 0){

	//	unsigned char processedPixels = 1;
	//	surf2Dwrite<unsigned char> (processedPixels, alphaSurface, sizeof (unsigned char) * x, y);

	//	// Initialized but not stable
	//	initialized = 128;
	//	surf2Dwrite<unsigned char> (initialized, maskSurface, sizeof (unsigned char) * x, y);

	//	// We initialize all the modes with the same parameters using this first
	//	// image. Since they are tried in order, they will slowly evolve to
	//	// reflect actual modes of the sequence.

	//	//sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
	//	//sigma0 = deltaSigma * sigmaMin;

	//	calcSigma(pixel[0], a, b, c, deltaSigma, &sigmaMin, &sigma0);

	//	const float initialWeight  = 1.0f / static_cast<float>(config.k);
	//	const float initialSortkey = initialWeight;
	//	//float initialSortkey = initialWeight / (static_cast<float>(COMPONENTS) * config.sigma_0);
	//	//float sigma0 = config.sigma_0;
	//	/*if (COMPONENTS == 1){
	//		sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
	//		sigma0 = sigmaMin * 2.5;
	//		initialSortkey *= sigma0;
	//	}*/
	//	for (int mode = 0; mode < config.k; ++mode) {
	//		for (int component = 0; component < COMPONENTS; ++component) {
	//			const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters (pixel[component], sigma0);
	//			gaussianParameters.write(gaussiansSurface, x, y, COMPONENTS * mode + component);
	//		}
	//		const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (initialWeight, initialSortkey);
	//		sortingParameters.write(sortingSurface, x, y, mode);
	//	}

		// This first pixel with valid data is unconditionally classified as background.
		const unsigned char background = 0;
		//surf2Dwrite<unsigned char> (background, outputSurface, sizeof (unsigned char) * x, y);
		//surf2Dwrite<unsigned char> (background, finalOutputSurface, sizeof (unsigned char) * x, y);
		filledOutput[y*parameters.width + x] = background;
		return;
	}

	/*unsigned char processedPixels;
	surf2Dread<unsigned char> (&processedPixels, alphaSurface, sizeof (unsigned char) *x, y);
	if (processedPixels < static_cast<unsigned char>(1.0f/config.alpha_min))
		processedPixels++;
	alpha = 1.0f / static_cast<float>(processedPixels);
	surf2Dwrite<unsigned char> (processedPixels, alphaSurface, sizeof (unsigned char) * x, y);*/
	

    int matchingMode = -1; // Not valid match
    for (int mode = 0; mode < config.k; ++mode) {
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (sortingSurface, x, y, mode);
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters[COMPONENTS];
        //for (int component = 0; component < COMPONENTS; ++component) {
            gaussianParameters[0].read(gaussiansSurface, x, y, COMPONENTS * mode);
        //}
        // Only the first matching mode is considered
        if ((0 > matchingMode) && (matchesMode<COMPONENTS, CUDA_VECTOR_T>(config, gaussianParameters, pixel))) {
            matchingMode = mode;
            //const float SQRT_2PI = 2.506628275f;
/*            float rho = alpha;


////////////	Aproximación del rho
            // TODO : Preguntar qué pichas hacer con la normalización, aunque tiene pinta de que normFactor = 1,
            // dado que rho debe estar entre 0 y 1 y alpha también lo está.
            //float normFactor = SQRT_2PI;
            //for (int component = 0; component < COMPONENTS; ++component) {
                const float arg = (pixel[0] - gaussianParameters[0].getMean())
                                  / gaussianParameters[0].getStdDev();
                // TODO: Cambiar esta exponencial por la tabla
                rho *= __expf(-0.5f * arg * arg);
                // TODO : Preguntar qué pichas hacer con la normalización
                //normFactor *= gaussianParameters[component].getStdDev();
            //}
            //rho /= normFactor;


			//rho /= sortingParameters.getWeight ();

            float stdDevSum = 0.0f;
			//float sigmaMin = config.sigma_min;
			//float sigma0 = config.sigma_0;
			//float sigma0 = 1; //Para que no me afecte en el color
			//if (COMPONENTS ==1){
			//sigmaMin = c+b*(gaussianParameters[0].getMean())+a*(gaussianParameters[0].getMean())*(gaussianParameters[0].getMean());
			//const float sigma0 = sigmaMin * 2.5;
			//float sigma0;
			//}
            //for (int component = 0; component < COMPONENTS; ++component) {
                gaussianParameters[0].setMean((1.0f - rho) * gaussianParameters[0].getMean()
                                                      + rho * pixel[0]);
                // TODO : Cerciorarse de que primero se actualiza la media y luego se actualiza la stdDev
                //gaussianParameters[component].setStdDev((1.0f - rho) * gaussianParameters[component].getStdDev()
                //                                        + rho * fabsf (pixel[component] - gaussianParameters[component].getMean()));
				//sigmaMin = c+b*(gaussianParameters[0].getMean())+a*(gaussianParameters[0].getMean())*(gaussianParameters[0].getMean());
				//sigma0 = sigmaMin * deltaSigma;
				calcSigma(gaussianParameters[0].getMean(), a, b, c, deltaSigma, &sigmaMin, &sigma0);

                gaussianParameters[0].setStdDev(__fsqrt_rn((1.0f - rho) * gaussianParameters[0].getStdDev() * gaussianParameters[0].getStdDev()
                                                        + rho * (pixel[0] - gaussianParameters[0].getMean()) * (pixel[0] - gaussianParameters[0].getMean())));
                gaussianParameters[0].setStdDev((sigmaMin > gaussianParameters[0].getStdDev())
                                                        ? sigmaMin : gaussianParameters[0].getStdDev());
                stdDevSum += gaussianParameters[0].getStdDev ();
                gaussianParameters[0].write(gaussiansAuxSurface, x, y, COMPONENTS * mode);
            //}
            sortingParameters.updatePositiveMatch(alpha, stdDevSum, sigma0);
       */} //else {
          //  sortingParameters.updateNegativeMatch(alpha);
        //}
       // sortingParameters.write(sortingAuxSurface, x, y, mode);
    }

   //((-1 == matchingMode) && (300 == x) && (240 == y)) ? printf ("No hay cerillas\n") : 0;
    // If the match is in the first mode we do not need to reorder the modes
/*    if (0 < matchingMode) {
        typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters matchingGaussian[COMPONENTS];
        //for (int c = 0; c < COMPONENTS; ++c) {
            matchingGaussian[0].read(gaussiansAuxSurface, x, y, COMPONENTS * matchingMode);
        //}
        const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters matchingSorting (sortingAuxSurface, x, y, matchingMode);

        for (int mode = (matchingMode - 1); mode >= 0; --mode) {
            {
                const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters otherSorting (sortingAuxSurface, x, y, mode);
                if (otherSorting.getSortingKey() >= matchingSorting.getSortingKey()) {
                    matchingSorting.write(sortingAuxSurface, x, y, mode + 1);
                    //for (int c = 0; c < COMPONENTS; ++c) {
                        matchingGaussian[0].write(gaussiansAuxSurface, x, y, COMPONENTS * (mode + 1));
                    //}
                    matchingMode = mode + 1;
                    break;
                }
                otherSorting.write(sortingAuxSurface, x, y, mode + 1);
            }
            //for (int c = 0; c < COMPONENTS; ++c) {
                const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters otherGaussian (gaussiansAuxSurface, x, y, COMPONENTS * mode);
                otherGaussian.write(gaussiansAuxSurface, x, y, COMPONENTS * (mode + 1));
            //}
        }
    }
*/
    // If there was no match, we must insert a new mode in place of the
    // last mode
  //  if (-1 == matchingMode) {
  //      matchingMode = config.k - 1;

		////sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
		////const float sigma0 = sigmaMin * deltaSigma;
		//calcSigma(pixel[0], a, b, c, deltaSigma, &sigmaMin, &sigma0);

  //      const float initialWeight = config.w_0;
		//const float initialSortkey = initialWeight;
  //      //float initialSortkey = initialWeight / (COMPONENTS * config.sigma_0);
		////float sigma0 = config.sigma_0;
		////float sigmaMin = config.sigma_min;
		////if (COMPONENTS == 1){
		//	//sigmaMin = c+b*(pixel[0])+a*(pixel[0])*(pixel[0]);
		//	//sigma0 = sigmaMin * 2.5;
		//	//initialSortkey *= sigma0;
		////}
  //      for (int component = 0; component < COMPONENTS; ++component) {
  //          const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters (pixel[component], sigma0);
  //          //((x == 200) && (y == 200)) ? printf ("  sigma_0: %f\n", getStdDev(gaussianParameters)) : 0;
  //          gaussianParameters.write(gaussiansSurface, x, y, COMPONENTS * matchingMode + component);
  //      }
  //      const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (initialWeight, initialSortkey);
  //      sortingParameters.write(sortingSurface, x, y, matchingMode);
  //  }

	//// If initialized but not stable, we must check if it becomes stable (only Mode 0)
	//if (initialized == 128){
	//	int mode = 0;
	//	typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (sortingSurface, x, y, mode);
 //       typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::GaussianParameters gaussianParameters[COMPONENTS];
 //       for (int component = 0; component < COMPONENTS; ++component) {
 //           gaussianParameters[component].read(gaussiansSurface, x, y, COMPONENTS * mode + component);
 //       }

	//	const float stdDevSum = gaussianParameters[0].getStdDev ();
	//	//float stdDevSum = 0.0f;
	//	//float stdDevSumMin = 0.0f;
 //       //for (int component = 0; component < COMPONENTS; ++component){
	//		//stdDevSum += gaussianParameters[component].getStdDev ();
	//		////stdDevSumMin += sortingParameters.getStdDevMin();
	//	//}
	//	const float weight = sortingParameters.getWeight();

	//	if ((weight > 0.6) && (stdDevSum < 1.1*sigmaMin)){
	//		initialized = 255;
	//		surf2Dwrite<unsigned char> (initialized, maskSurface, sizeof (unsigned char) * x, y);
	//	}

	//}

    // Now we must renormalize the weights of the modes before classifying the
    // pixel as fore- or background.
    bool pixelIsBackground = false;
	if (-1 != matchingMode) {
		float weightNormalization = 0.0f;
		float accumulatedWeightBeforeMatch = 0.0f;
		for (int mode = 0; mode < config.k; ++mode) {
			const typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (sortingSurface, x, y, mode);
			weightNormalization += sortingParameters.getWeight();
		}
		for (int mode = 0; mode < config.k; ++mode) {
			typename MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::SortingParameters sortingParameters (sortingSurface, x, y, mode);
			const float newWeight = sortingParameters.getWeight()/ weightNormalization;
	//        accumulatedWeightBeforeMatch += newWeight;
	//        sortingParameters.setWeight(newWeight);
	//        sortingParameters.setSortingKey(sortingParameters.getSortingKey() / weightNormalization);
	//        sortingParameters.write (sortingSurface, x, y, mode);
			if (mode == matchingMode) {
			  pixelIsBackground = (accumulatedWeightBeforeMatch < config.thresh) ? true : false;
			}
			//if (matchingMode == 2)
				//pixelIsBackground = true;
			accumulatedWeightBeforeMatch += newWeight;
			sortingParameters.setWeight(newWeight);
			sortingParameters.setSortingKey(sortingParameters.getSortingKey() / weightNormalization);
			sortingParameters.write (sortingSurface, x, y, mode);
		}
	}
    //((x == 300) && (y == 240)) ? printf ("%d\n", matchingMode) : 0;
    if (pixelIsBackground || initialized < 128) {
        const unsigned char finalPixel = 0;
        //surf2Dwrite<unsigned char> (finalPixel, outputSurface, sizeof(unsigned char) * x, y);
		//surf2Dwrite<unsigned char> (finalPixel, finalOutputSurface, sizeof (unsigned char) * x, y);
		filledOutput[y*parameters.width + x] = finalPixel;
    } else {
        const unsigned char finalPixel = 255;
        //surf2Dwrite<unsigned char> (finalPixel, outputSurface, sizeof(unsigned char) * x, y);
		//surf2Dwrite<unsigned char> (finalPixel, finalOutputSurface, sizeof (unsigned char) * x, y);
		filledOutput[y*parameters.width + x] = finalPixel;
    }
}

template<int COMPONENTS, typename CUDA_VECTOR_T>
void MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::processImageOnlyDetection (Mat const *input, Mat *output, Mat *finalOutput, unsigned short int *inputDepth, Npp8u *filledOutput, float a, float b, float c, float deltaSigma)
//void MixtureOfGaussians<COMPONENTS, CUDA_VECTOR_T>::processImage (fipImage const *input, fipImage* output)
{
    /*++this->processedFrames;
    float alpha = 1.0f / static_cast<float>(this->processedFrames);
    if (alpha < this->config.alpha_min) {
        alpha = this->config.alpha_min;
    }*/
    float alpha = 0.0f;
    //copyImageToArray(*input, this->inputArray);
	//this->foregroundColorArray = inputColorArray;
    /*if (!this->initialised) {
        this->initialised = true;
        mogInitialiseKernel<COMPONENTS, CUDA_VECOR_T>
                           <<<this->gridsize, this->blocksize>>>(this->config,
                                                                this->parameters, 
																 a, b, c, deltasigma);
        CUDA_SAFE_CALL (cudagetlasterror());
    } else {*/
    mogProcessOnlyDetectionKernel<COMPONENTS, CUDA_VECTOR_T>
                    <<<this->gridSize, this->blockSize>>>(alpha,
                                                            this->config,
                                                            this->parameters,
															inputDepth,
															filledOutput,
															a, b, c, deltaSigma);
    //}
    //copyImageFromArray(*output, this->outputArray);
	//copyImageFromArray(*finalOutput, this->finalOutputArray);
}


template <>
__device__ void initializePixel<unsigned short> (unsigned short int pixel[1], unsigned short int *inputDepth, int width) {
    const int x = blockIdx.x * blockDim.x + threadIdx.x;
    const int y = blockIdx.y * blockDim.y + threadIdx.y;
    //const unsigned short readData = tex2D(inputTexture, x, y);
    //pixel[0] = static_cast<unsigned short>(readData); /// static_cast<float>(5400);
	//pixel[0] = readData;
	pixel[0] = inputDepth[y*width + x];
}

template class MixtureOfGaussians<1, unsigned short>;

